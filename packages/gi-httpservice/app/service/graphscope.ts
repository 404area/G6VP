// @ts-nocheck

import { Service } from 'egg';

import gremlin from 'gremlin_patch';
import BigNumber from 'bignumber.js';
// @ts-ignore
import FormStream from 'formstream';
import fs from 'fs';
import { readGraphScopeConfig } from '../util';

interface ConnectProps {
  engineServerURL: string;
  httpServerURL: string;
  isStringType: boolean;
}

/**
 * 初始化 Gremlin 客户端，支持通过 Gremlin 语句查询
 * @param gremlinServer Endpoint of gremlin server
 * @param account Authenticator of gremlin server
 */
function initGremlinClient(gremlinServer: string, account = { username: '', password: '' }) {
  if (!account.hasOwnProperty('username') || !account.hasOwnProperty('password')) {
    throw new Error('Authenticator failed: username or password not exists.');
  }
  const authenticator = new gremlin.driver.auth.PlainTextSaslAuthenticator(account.username, account.password);
  const client = new gremlin.driver.Client(gremlinServer, {
    traversalSource: 'g',
    authenticator,
  });

  console.log(`Gremlin client init on server ${gremlinServer}`);
  return client;
}

function closeGremlinClient(client): void {
  console.log('Gremlin client close');
  try {
    client.close();
  } catch (error) {}
}

class GraphComputeService extends Service {
  async connectGraphScope(params: ConnectProps) {
    const { isStringType, ...others } = params;
    const oidType = isStringType ? 'string' : 'int64_t';
    const config = {
      ...others,
      oidType,
    };

    fs.writeFileSync(`${__dirname}/GRAPHSCOPE_CONFIG.json`, JSON.stringify(config, null, 2), 'utf-8');
    return {
      success: true,
      data: others,
      code: 200,
    };
  }

  /**
   * Whether the value was generated by GraphScope pathExpand operator.
   * https://graphscope.io/docs/latest/interactive_engine/supported_gremlin_steps.html#pathexpand
   * @param value: the result fetching from the gremlin server
   */
  isGeneratedbyGSPathExpandOperator(value) {
    try {
      let isGSPath = true;
      let hasEdge = false;
      const entries = value.entries();
      for (const current of entries) {
        // the result of PathExpand operator is a path consisting of a set of vertex and edge
        isGSPath &&= current instanceof gremlin.structure.Vertex || current instanceof gremlin.structure.Edge;
        // edgeInfo is needed for graph visualization
        if (current instanceof gremlin.structure.Edge) {
          hasEdge = true;
        }
      }
      return isGSPath && hasEdge;
    } catch (error) {
      return false;
    }
    return false;
  }

  /**
   * Convert gremlin vertex/edge data structure into js object.
   * @param client: gremlin client
   * @param value: gremlin data structure
   */
  async jsonGraphData(client, value) {
    const obj = {};
    const { id, label, properties } = value;
    // id, label
    obj.id = `${id}`;
    obj.label = label;
    // properties
    if (properties) {
      // general gremlin standard
      const elementProp = {};
      for (const key in properties) {
        const currentProp = properties[key];
        if (currentProp && currentProp[0]) {
          elementProp[`${key}`] = currentProp[0].value;
        }
      }
      obj.data = elementProp;
    } else {
      // now graphscope only support to query properties of vertex
      // `g.E(<id>).valueMap()` isn't support yet.
      // TODO: edge properties, waiting for GIE engine
      if (value instanceof gremlin.structure.Vertex) {
        const propertiesArr = await this.queryNodesProperties(client, [id]);
        obj.data = propertiesArr[0];
      }
    }
    // edge also need src/dst information
    if (value instanceof gremlin.structure.Edge) {
      const { inV, outV } = value;
      obj.inV = await this.jsonGraphData(client, inV);
      obj.outV = await this.jsonGraphData(client, outV);
    }
    return obj;
  }

  /**
   * Query the properties of nodes in batch.
   * @param client: The gremlin client
   * @param nodeIds: List of node's id
   */
  async queryNodesProperties(client, nodeIds) {
    const propertiesArr = [];
    if (!nodeIds || nodeIds.length === 0) {
      return propertiesArr;
    }

    for (const id of nodeIds) {
      const propertyGremlinSQL = `g.V(${id}).valueMap()`;
      const propertiesResult = await client.submit(propertyGremlinSQL);

      if (propertiesResult && propertiesResult.length === 1) {
        for (const properties of propertiesResult) {
          const entries = properties.entries();
          const currentObj = {};
          for (const current of entries) {
            const [key, value] = current;
            currentObj[key] = value.join(',');
          }
          propertiesArr.push(currentObj);
        }
      } else {
        propertiesArr.push({});
      }
    }
    return propertiesArr;
  }

  /**
   * Query the properties of edges in batch.
   * @param client: The gremlin client
   * @param edgeIds: List of edge's id
   */
  async queryEdgesProperties(client, edgeIds) {
    // TODO: Query edge properties isn't support in GraphScope yet.
    // Need to consider the dummy edge of PathExpand operator.
    const propertiesArr = [];
    return {
      success: true,
      code: 200,
      message: '属性查询成功',
      data: propertiesArr,
    };
  }

  /**
   * 通过 Gremlin 语句查询
   * @param gremlinSQL Gremlin 查询语句
   */
  async queryByGremlinLanguage(params) {
    const { value: gremlinCode, gremlinServer, graphScopeAccount } = params;
    console.log(`Execute query ${gremlinCode} on server ${gremlinServer}`);

    // init gremlin client
    const client = initGremlinClient(gremlinServer, graphScopeAccount);

    let result = [];
    try {
      result = await client.submit(gremlinCode);
    } catch (error) {
      // close gremlin client
      closeGremlinClient(client);
      return {
        success: false,
        code: 200,
        message: `Gremlin 查询失败。${error}`,
        data: {
          nodes: [],
          edges: [],
        },
      };
    }

    // console.log('[DEBUG] Fetch gremlin result: ', result);

    let mode = 'graph';
    const tableResult: any[] = [];

    const edgeItemsMapping = {};
    const nodeItemsMapping = {};
    for (const value of result) {
      if (value instanceof gremlin.structure.Vertex) {
        // vertex
        const vertexInfo = await this.jsonGraphData(client, value);
        nodeItemsMapping[vertexInfo.id] = {
          ...vertexInfo,
          nodeType: vertexInfo.label,
        };
      } else if (value instanceof gremlin.structure.Edge) {
        const edgeInfo = await this.jsonGraphData(client, value);
        const srcVertexInfo = edgeInfo.outV;
        const dstVertexInfo = edgeInfo.inV;
        // edge
        edgeItemsMapping[edgeInfo.id] = {
          ...edgeInfo,
          edgeType: edgeInfo.label,
          source: srcVertexInfo.id,
          target: dstVertexInfo.id,
        };
        // source vertex
        nodeItemsMapping[srcVertexInfo.id] = {
          ...srcVertexInfo,
          nodeType: srcVertexInfo.label,
        };
        // destination vertex
        nodeItemsMapping[dstVertexInfo.id] = {
          ...dstVertexInfo,
          nodeType: dstVertexInfo.label,
        };
      } else if (value instanceof gremlin.structure.Path) {
        // path isn't supported in graphscope yet.
        // https://graphscope.io/docs/latest/interactive_engine/supported_gremlin_steps.html#path
        // TODO: waiting for GIE engine.
      } else if (this.isGeneratedbyGSPathExpandOperator(value)) {
        // TODO: waiting for GI engine.
      } else {
        mode = 'table';
        if (typeof value === 'number' || typeof value === 'string' || value instanceof BigNumber) {
          // e.g. `g.V().count()`, `g.V().id()`, `g.V().label()`
          tableResult.push(value);
        } else {
          // e.g. `valueMap()`, `expandPath()`
          // https://graphscope.io/docs/latest/interactive_engine/supported_gremlin_steps.html#pathexpand
          const entries = value.entries();
          const currentObj = {} as any;
          for (const current of entries) {
            const [key, v] = current;
            if (typeof v === 'number') {
              currentObj[key] = v;
            } else if (v instanceof gremlin.structure.Vertex || v instanceof gremlin.structure.Edge) {
              currentObj[key] = await this.jsonGraphData(client, v);
            } else {
              currentObj[key] = JSON.stringify(v);
            }
          }
          tableResult.push(currentObj);
        }
      }
    }

    // close gremlin client
    closeGremlinClient(client);

    if (mode === 'graph') {
      // convert map into arraylist
      const nodes = [];
      const edges = [];
      for (const nodeKey in nodeItemsMapping) {
        nodes.push(nodeItemsMapping[nodeKey]);
      }
      for (const edgeKey in edgeItemsMapping) {
        edges.push(edgeItemsMapping[edgeKey]);
      }
      return {
        success: true,
        code: 200,
        message: 'Gremlin 查询成功',
        mode,
        data: {
          nodes,
          edges,
          mode,
          tableResult,
        },
      };
    }
    // table mode
    return {
      success: true,
      code: 200,
      message: 'Gremlin 查询成功',
      mode,
      data: {
        nodes: [],
        edges: [],
        mode,
        tableResult,
      },
    };
  }

  /**
   * 邻居查询
   * @param params
   */
  async queryNeighbors(params) {
    const { id = [], sep, gremlinServer, graphScopeAccount } = params;
    // multi-hop query
    let hops = '';
    for (let i = 0; i < sep - 1; i++) {
      hops += '.both()';
    }
    // init gremlin client
    const client = initGremlinClient(gremlinServer, graphScopeAccount);
    // gremlin query with limits 600
    const gremlinSQL = `g.V(${id.join(',')})${hops}.bothE().limit(600)`;
    const result = await client.submit(gremlinSQL);

    // console.log('[DEBUG] Fetch gremlin result: ', result);

    const edgeItemsMapping = {};
    const nodeItemsMapping = {};
    for (const value of result) {
      if (value instanceof gremlin.structure.Edge) {
        // value always edge
        const edgeInfo = await this.jsonGraphData(client, value);
        const srcVertexInfo = edgeInfo.outV;
        const dstVertexInfo = edgeInfo.inV;
        // edge
        edgeItemsMapping[edgeInfo.id] = {
          ...edgeInfo,
          edgeType: edgeInfo.label,
          source: srcVertexInfo.id,
          target: dstVertexInfo.id,
        };
        // source vertex
        nodeItemsMapping[srcVertexInfo.id] = {
          ...srcVertexInfo,
          nodeType: srcVertexInfo.label,
        };
        // destination vertex
        nodeItemsMapping[dstVertexInfo.id] = {
          ...dstVertexInfo,
          nodeType: dstVertexInfo.label,
        };
      }
    }
    // close gremlin client
    closeGremlinClient(client);
    //  convert map into arraylist
    const nodes = [];
    const edges = [];
    for (const nodeKey in nodeItemsMapping) {
      nodes.push(nodeItemsMapping[nodeKey]);
    }
    for (const edgeKey in edgeItemsMapping) {
      edges.push(edgeItemsMapping[edgeKey]);
    }
    return {
      success: true,
      code: 200,
      message: '邻居查询成功',
      data: {
        nodes,
        edges,
      },
    };
  }

  // TODO：queryNodesProperties 统一
  /**
   * 查询节点属性详情
   * @param params 节点 ID
   */
  async queryElementProperties(params) {
    const { id = [], type, gremlinServer, graphScopeAccount } = params;

    const client = initGremlinClient(gremlinServer, graphScopeAccount);

    if (type === 'edge') return await this.queryEdgesProperties(client, id);

    // 查询属性的 Gremlin 已经
    const gremlinSQL = `g.V(${id.join(',')}).valueMap()`;

    console.log('查询语句', gremlinSQL);
    const result = await client.submit(gremlinSQL);
    const propertiesArr = [];
    console.log('查询属性值结果', result);

    for (const properties of result) {
      const entries = properties.entries();
      const currentObj = {};
      for (const current of entries) {
        const [key, value] = current;
        currentObj[key] = value.join(',');
      }
      propertiesArr.push(currentObj);
    }

    // 构造 { id: properties } 对象
    const resultObj = {};
    for (let i = 0; i < id.length; i++) {
      resultObj[id[i]] = propertiesArr[i];
    }

    closeGremlinClient(client);
    return {
      success: true,
      code: 200,
      message: '属性查询成功',
      data: resultObj,
    };
  }

  // 分布式暂时不支持，但保留
  /**
   * 执行 GraphScope 图算法
   * @param params 算法参数
   */
  async execAlgorithm(params) {
    const {
      name,
      graphName,
      colomnName,
      maxRound = 10,
      limit = 100,
      sortById,
      vertex_label,
      edge_label,
      delta = 0.85,
      weight = 1,
      src,
      tolerance,
      k,
    } = params;

    // 根据不同算法类型，过滤不需要的参数
    const algorithmParams = {
      name,
      limit,
      sortById,
      vertex_label,
      edge_label,
      graph_name: graphName,
    };
    if (name === 'pagerank') {
      algorithmParams.delta = delta;
    }

    if (name === 'pagerank' || name === 'lpa' || name === 'eigenvector_centrality') {
      algorithmParams.max_round = maxRound;
    }

    if (name === 'eigenvector_centrality') {
      algorithmParams.tolerance = tolerance;
    }

    if (name === 'sssp') {
      algorithmParams.weight = weight;
      algorithmParams.src = src;
    }

    if (name === 'k_core') {
      algorithmParams.k = k;
    }

    console.log('执行图算法参数', algorithmParams);
    const { engineServerURL } = readGraphScopeConfig();

    const result = await this.ctx.curl(`${engineServerURL}/api/graphservice/algorithm`, {
      method: 'GET',
      data: algorithmParams,
      timeout: [10000, 30000],
      dataType: 'json',
    });

    if (!result || !result.data) {
      return result;
    }

    const { result: algorithmResult, code, success, message, context_name } = result.data;

    // 算法执行失败
    if (!success) {
      return result.data;
    }

    const { id: dataIds, result: dataResult } = JSON.parse(algorithmResult);
    const algorithmArr = [];
    for (const key in dataIds) {
      const nodeId = dataIds[key];
      const nodeValue = dataResult[key];
      algorithmArr.push({
        id: nodeId,
        value: nodeValue,
      });
    }

    // 算法执行成功后，将结果写入到数据中，并且更新 Project 中 expandInfo 字段
    const addColumnResult = await this.addColumnToData({
      contextName: context_name,
      colomnName,
      needGremlin: true,
      graphName,
    });

    if (!addColumnResult || !addColumnResult.success) {
      return {};
    }
    const { graph_name, graph_url } = addColumnResult;

    // 算法执行成功，返回结果
    return {
      code,
      success,
      message,
      graphName: graph_name,
      gremlinClientURL: graph_url,
      data: algorithmArr,
    };
  }

  /**
   * 执行算法成功后，将算法结果写到数据指定字段上
   * @param params
   */
  async addColumnToData(params) {
    const { engineServerURL } = readGraphScopeConfig();

    const { graphName, contextName, colomnName, needGremlin } = params;
    const result = await this.ctx.curl(`${engineServerURL}/api/graphservice/addColumn`, {
      method: 'GET',
      data: {
        graph_name: graphName,
        context_name: contextName,
        column_name: colomnName,
        need_gremlin: needGremlin,
      },
      timeout: [10000, 30000],
      dataType: 'json',
    });

    if (!result || !result.data) {
      return result;
    }

    return result.data;
  }

  /**
   * 获取指定引擎的子图列表
   * @param params
   * @returns
   */
  async listSubgraph(params) {
    const { engineServerURL } = readGraphScopeConfig();

    let result;
    try {
      result = await this.ctx.curl(`${engineServerURL}/api/v1/graph`, {
        method: 'GET',
        data: {
          // @ts-ignore
          // graph_name: graphName,
        },
        dataType: 'json',
      });
    } catch (error) {
      return {
        success: false,
        code: 200,
        message: `子图列表查询失败：${error}`,
      };
    }

    if (!result || !result.data) {
      return {
        success: false,
        code: 200,
        message: `子图列表查询失败：${result}`,
      };
    }

    return {
      success: true,
      code: 200,
      message: '子图列表查询成功',
      data: result.data.data,
    };
  }
}

export default GraphComputeService;
